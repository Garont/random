server {
	listen 80 default_server;
	listen [::]:80 default_server;

	error_log /var/log/nginx/dbg.log debug;

	location /fw {
	         #default_type 'text/plain';

		content_by_lua_block {

			ngx.header["My-header"]= "foo"

		       	local cjson = require "cjson"
		       	local resty_sha1 = require "resty.sha1"
    		       	local sha1 = resty_sha1:new()
			if ngx.var.arg_debug then
    				if not sha1 then
        				ngx.say("failed to create the sha1 object")
        				return
    				end
			end

                       if ngx.var.arg_debug then
                           ngx.say(cjson.encode(ngx.req.get_uri_args()))
                       end

 	               local mysql = require "resty.mysql"
        	       local db, err = mysql:new()
              	       if not db then
			   if ngx.var.arg_debug then
                	   	ngx.say("failed to instantiate mysql: ", err)
                    	   	return
			   end
                       end
		       db:set_timeout(1000)

	               local ok, err, errcode, sqlstate = db:connect{
                       host = "127.0.0.1",
             	       port = 3306,
                       database = "fw",
                       user = "fw",
                       password = "pass",
                       max_packet_size = 1024 * 1024 }

                       if not ok then
			   if ngx.var.arg_debug then
 	                          ngx.say("failed to connect: ", err, ": ", errcode, " ", sqlstate)
        	                  return
                           end
                       end

		       if ngx.var.arg_debug then
	                       ngx.say("connected to mysql.")
		       end

		       -- collecting ipv4rules for filter chain

			if ngx.var.arg_ipv == "4" then
				if ngx.var.arg_env == "prod" then
		       			res, err, errcode, sqlstate =
						db:query("(select rule from ipv4base where `chain` = 'OUTPUT' AND `table` = 'filter' order by ruleid) UNION ALL (select rule from ipv4extra where `chain` = 'OUTPUT' AND `table` = 'filter' AND host = '" .. ngx.unescape_uri(ngx.var.arg_server) .."' order by ruleid);")
				elseif ngx.var.arg_env == "dev" then
					res, err, errcode, sqlstate =
						db:query("select rule from ipv4dev where `chain` = 'OUTPUT' AND `table` = 'filter' order by ruleid;")
				elseif ngx.var.arg_env == "stage" then
						db:query("select rule from ipv4stage where `chain` = 'OUTPUT' AND `table` = 'filter' order by ruleid;")
				end

			elseif ngx.var.arg_ipv == "6" then
				if ngx.var.arg_env == "prod" then
	                                res, err, errcode, sqlstate =
        	                                db:query("(select rule from ipv6base where `chain` = 'OUTPUT' AND `table` = 'filter' order by ruleid) UNION ALL (select rule from ipv6extra where `chain` = 'OUTPUT' AND `table` = 'filter' AND host = '" .. ngx.unescape_uri(ngx.var.arg_server) .."' order by ruleid);")
                                elseif ngx.var.arg_env == "dev" then
                                        res, err, errcode, sqlstate =
                                                db:query("select rule from ipv6dev where `chain` = 'OUTPUT' AND `table` = 'filter' order by ruleid;")
                                elseif ngx.var.arg_env == "stage" then
                                                db:query("select rule from ipv6stage where `chain` = 'OUTPUT' AND `table` = 'filter' order by ruleid;")
                                end
			end

              		if not res then
				if ngx.var.arg_debug then
               				ngx.say("bad result: ", err, ": ", errcode, ": ", sqlstate, ".")
					return
				end
				res = {miss = {rule="\n\n\tRules missed\n\n"}}
               		end

	       		if ngx.var.arg_server then
		       		local prefilter = "#GENERATED BY SALTSTACK. PLEASE USE IT FOR UPDATING THIS FILE\n*filter\n:INPUT ACCEPT [0:0]\n:FORWARD ACCEPT [0:0]\n:OUTPUT ACCEPT [0:0]\n"
		       		local rules = ""
	               	       	for k,v in pairs(res) do
		                	rules = rules..v.rule..'\n'
	       		        end
	    	       		local postfilter = "-A INPUT -j DROP\nCOMMIT\n"

	       	       		-- other rules will be placed here
	       	       		local prepostmangle = "*mangle\n:PREROUTING ACCEPT [0:0]\n:INPUT ACCEPT [0:0]\n:FORWARD ACCEPT [0:0]\n:OUTPUT ACCEPT [0:0]\n:POSTROUTING ACCEPT [0:0]\nCOMMIT"

		       		local returnRules = prefilter..rules..postfilter..prepostmangle
		       		local sha1hash = sha1:update(returnRules)
				local sha1hash = sha1:update("\n")
		       		local digest = sha1:final()
		       		local str = require "resty.string"

				if ngx.var.arg_fwrules then
					ngx.header["Content-Type"]="text/plain;charset=utf-8"
		       			ngx.say(returnRules)
		       		end

				if ngx.var.arg_hash then
					ngx.header["Content-Type"]="text/plain;charset=utf-8"
					if ngx.var.arg_ipv == "4" then
						ngx.say(str.to_hex(digest))
					elseif ngx.var.arg_ipv == "6" then
                                                ngx.say(str.to_hex(digest))
					end
				end
	       		end -- ngx.var.arg_server

		}


	}


}
